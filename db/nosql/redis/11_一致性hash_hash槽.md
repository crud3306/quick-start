一：概述
=============
当数据量增长到一定程度，往往通过存储节点扩容，来分担数据。当加入新节点后，数据在分配时，如何保证数据既能正确读写路由，又能让数据迁移变得简单快捷？大家会一口同声的说道采用一致性哈希方案。但是，生产与实践中，redis最新版本已经放弃对一致性哈希的应用，提出了哈希槽(Hashslot）的概念，以下将通过两者的分析与对比，领略一下哈希槽的魅力。（最新信息请关注微信公众号： 白白家族）

二：分析与对比
=============
我们先看看 一致性哈希 和 哈希槽的实现原理，才能更深入的了解。

2.1 一致性哈希算法（Consistent Hashing）
-------------
1）声明环空间:

将数组[0，1，2，… 2^32-1]形成首尾相连的环形结构，按顺时针方向组织，其中0和2^32-1在零点中方向重合，如下图圆环所示


2）分配服务节点

将服务器的ip或主机名作为关键字进行哈希取值，映射到数组圆环上，例如hash(server1)/2^32 = 1000, 例如hash(server3) /2^32= 50000, hash(server2) /2^32 = 900000, 分别映射到 数组第1000/50000/900000的位置上


3）分配数据节点

将数据key进行哈希取值，映射到数组圆环上，从映射位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。

例如，以下四个数据A、B、C、D，

Hash(A) /2^32= 333

Hash(B) /2^32= 4000

Hash(C) /2^32= 70000

Hash(D) /2^32=800000

因为0<333<1000，所以数据A映射到server 1服务节点，同理，1000< 4000<50000，所以映射到server 3服务节点，以此类推，数据C，D映射到server 2服务节点，至此，一致性Hash以及数据组建完成（如下图）


4）可扩展性分析

下面分析一致性哈希算法的可扩展性。

如果我们在系统中增加一台服务器 Server 4，此时A、D、C不受影响，只有B需要重定位到新的Server4。因为B节点逆时针查找的第一台服务节点是Server4。

所以，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。


2.2 哈希槽算法
-------------
我们再来考虑 hash slot 的实现方式：

1）声明slot空间

将数组[ 0，1，2，… 2^14-1 ]形成hash slot空间


2）分配数据节点

将数据key进行哈希取值，映射已经固定大小的hash slot空间上。

例如，我们取slot位置总数为 2^14 , 那么以下三个数据A、B、C，分别映射到以下slot中

Hash(A) /2^14= 333

Hash(B) /2^14= 4000

Hash(C) /2^14= 7000


3）组建映射表

上述第2点中，已经把数据分在了333/4000/7000 这3 个slot 中了，目前需要组建映射关系，也就是说：

0<= slot <1000 映射到server1上，

1000<=slot<5000映射到server2上，

5000<=slot<2^14 会映射到server3上，



4）扩容性分析

当发生扩容时候，我们只需要定义映射表关系即可，随意改变slot的映射关系，重要的事情再说一遍，映射表才是哈希槽的精髓，可以按需求随意组合，以下举个例子：

0<=slot< 900 映射到server1上，

1000<=slot<4000映射到server2上，

5000<=slot<2^14 会映射到server3上，

900<=slot<1000 会映射到server4上，

4000<=slot<5000 会映射到server4上，




2.3 对比分析

当发生扩容时候，哈希槽采用灵活的可配置映射表，可以随意组织映射到新增server上面的slot数，比一致性hash的算法更灵活方便；同时也给开发人员手工配置更大的简洁性。

其次，在数据迁移时，一致性hash 需要算哪些key是落在新增服务节点的数据，然后迁移这部分数据，哈希槽则直接将一个slot对应的数据全部迁移，算法明确以及实现更简单。



